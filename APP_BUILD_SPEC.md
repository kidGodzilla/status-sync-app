# Build Spec: macOS Presence Menubar App (SwiftUI) + Consent + Contacts Picker

You are writing a macOS menubar app in Swift using SwiftUI. The app shares and reads "presence" (active/away/asleep) between two people using a minimal Node relay server. Presence sharing is CONSENSUAL and requires explicit approval.

## Hard Constraints (Do Not Violate)
- Platform: macOS only
- Language: Swift
- UI: SwiftUI
- Menubar app only (no Dock icon)
- Use public Apple APIs only
- Allowed permission: Contacts (for selecting a person), Accessibility (for Focus state detection)
- Not allowed: Screen Recording, Calendar
- Backend transport: HTTP polling only (no WebSockets for v1)
- No DB in app
- Do not send contacts or contact lists to server

## Definitions
- **user_id**: a random stable ID generated by the app on first run (UUID string). This is the ONLY identity used by the server.
- **Peer**: a person the user wants to see presence for and optionally contact via iMessage/FaceTime.
- **Contact handle**: phone number or email. This is for launching iMessage/FaceTime only and is local UI data (not protocol identity).

## Presence Model
- Compute local presence:
  - "active" if last input < 120 seconds
  - "away" otherwise
  - "asleep" optionally if user toggles manual Sleep or you add a configurable sleep window (v1 can omit asleep and only use active/away)
- Poll/update intervals:
  - POST local presence every 30 seconds
  - Poll inbox for requests every 30 seconds
  - Poll inbox for tokens every 30 seconds
  - Poll peer presence every 30 seconds per configured peer (only if you have a valid capability token for that peer)

## Backend API (Base URL configurable in Settings)
Assume the server has these endpoints:

1) POST /presence/update
Body: { user_id, state: "active"|"away"|"asleep", device: "mac", timestamp: unixSeconds }

2) POST /requests/create
Body: { from_user_id, to_user_id }

3) GET /requests/inbox?user_id=...
Returns: { ok, requests: [{ id, from, to, createdAt, expiresAt, status }] }

4) POST /requests/respond
Body: { to_user_id, request_id, decision: "allow"|"deny" }
- If allow, server issues a capability token and stores it in requester's token inbox

5) GET /tokens/inbox?user_id=...
Returns: { ok, tokens: [{ from, token, issuedAt, expiresAt }] }

6) POST /tokens/ack
Body: { user_id, token }

7) POST /presence/get
Body: { requester_user_id, target_user_id, capability_token }
Returns: { ok, presence: null OR { user_id, state, device, timestamp } }

## Consent Flow (Must Implement)
- User A wants to see User B's presence:
  - A must know B's user_id (exchange out-of-band: copy/paste).
  - A sends /requests/create(from=A, to=B).
- User B app polls /requests/inbox:
  - shows a prompt/card in the menu: "Presence request from <from_user_id>" with Allow/Deny.
  - If Allow: call /requests/respond(to=B, request_id, allow).
  - If Deny: call /requests/respond(to=B, request_id, deny).
- User A polls /tokens/inbox:
  - when a token arrives, store it locally as "capability token for peer B"
  - call /tokens/ack to clear it from inbox (optional)
- Only once A has a stored token for B can A call /presence/get to read B presence.

## UI Requirements
Use MenuBarExtra.

Menu should include:
- Top: Your status (Active/Away) and your user_id (copy button)
- Divider
- Section: Peer list (v1 allow 1 peer, but implement data model to allow many)
  - Peer display name (from contacts or manual)
  - Peer presence (unknown/active/away/asleep + last updated time)
  - Buttons: "Message", "FaceTime", "FaceTime Audio"
- Divider
- Section: Incoming requests (if any)
  - For each request: show from_user_id and Allow/Deny buttons
- Divider
- Settingsâ€¦ (opens settings window)
- Quit

### Settings window
- Server base URL (string)
- Presence threshold seconds (default 120)
- Poll interval seconds (default 30)

## Contacts Permission & Peer Creation
When user clicks "Add Peer":
- Show CNContactPickerViewController to pick a person.
- Extract:
  - display name
  - one preferred handle (choose email first; if none, phone).
- Then ask user to paste the peer's user_id (required for protocol).
- Save Peer record:
  - peer_user_id (string; protocol identity)
  - display_name (string; from contact)
  - handle (string; for iMessage/FaceTime deep links)
  - capability_token (nullable string)

Important:
- Contacts are used only to pick a friendly name/handle.
- Do not try to resolve peer_user_id from contacts.
- Do not upload contacts to server.

## Local Storage
Persist locally using UserDefaults (Codable) or a JSON file:
- my_user_id
- server_base_url
- peers array (including capability tokens)
- any preferences

## Network Layer Requirements
- Use URLSession
- Implement a small API client with:
  - getRequestsInbox()
  - respondToRequest()
  - createRequest()
  - getTokensInbox()
  - ackToken()
  - updatePresence()
  - getPeerPresence()
- Handle server errors gracefully and quietly.
- If server is unreachable: show "offline" in UI but do not spam alerts.

## Presence Monitor Requirements
- Use CGEventSource.secondsSinceLastEventType(.combinedSessionState) for idle time.
- Determine "active/away" from idle time.
- Update published state on a timer.

## iMessage / FaceTime Launch
- iMessage: sms:<handle>
- FaceTime video: facetime://<handle>
- FaceTime audio: facetime-audio://<handle>
Use NSWorkspace.shared.open(URL).

## Privacy Statement (Include)
Include in Settings UI:
"This app determines whether your Mac is in use based solely on time since last keyboard/mouse input. It does not record keystrokes, screen contents, app usage, or messages. Contacts access is used only to select a name/handle for quick Message/FaceTime shortcuts and is never uploaded."

## Deliverables
- A compiling Xcode project (macOS SwiftUI)
- Menubar UI + Settings window
- Contacts picker flow to create a peer
- Consent request inbox and Allow/Deny actions
- Polling timers
- Presence update loop
- Peer presence polling using stored capability tokens

## Implementation Guidance (Do Not Overbuild)
- Keep code small and readable
- No third-party deps
- No websockets
- No encryption beyond TLS; server already issues HMAC tokens
- Avoid complex state machines; simple timers are fine

